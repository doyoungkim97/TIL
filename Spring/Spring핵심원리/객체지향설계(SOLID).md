# 객체지향설계 SOLID

> 💻 스프링 핵심 기술 - 기초
해당 강의는 김영한님의 스프링 핵심 원리- 기초 강의를 수강하여 공부한 내용은 간략하게 기록하는 기록장
[스프링 핵심 원리 기초 강의](https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%95%B5%EC%8B%AC-%EC%9B%90%EB%A6%AC-%EA%B8%B0%EB%B3%B8%ED%8E%B8#)

객체지향 언어를 사용하면서 설계의 5가지 원칙인 SOLID를 들어봤지만 정확히 어떤 원리인지는 명확하게 모른다.
이걸 Spring 핵심 원리를 파악하기 전에 한번 보고 들어가보자

## SOLID 
좋은 객체 지향 설계의 5가지 원칙 이라고 불린다.
 
5가지는 각각
SRP : 단일 책임 원칙 (single responsibility principle)
OCP : 개방-폐쇠 원칙 (Open/closed principle)
LSP : 리스코프 치환 원칙 (Liskov substitution principle)
ISP : 인터페이스 분리 원칙 (Interface segregation principle)
DIP : 의존관계 역전 원칙 (Dependency inversion principle)

이제 각각 하나씩 무슨 원칙인지 알아보자

## SRP 단일 책임 원칙 
하나의 클래스는 하나의 책임만 가져야한다.
하나의 책임은 사실 모호하다.
큰 경우도 있고 작은 경우도 있음

중요한 기준은 바로 변경
변경이 있을때 파급 효과가 적으면 단일 책임 원칙을 잘 따른 것이다.
> UI 변경시 객체 생성과 사용을 분리하는 것

## OCP 개방-폐쇠 원칙
소프트웨어 요소는 **확장에는 열려있으나 변경에는 닫혀** 있어야 한다
확장하려면 기존 코드를 바꿔야하는데 이게 무슨 헛소리냐 라고 생각할 수 있다
![](https://velog.velcdn.com/images/kimdodo/post/231edbba-5f38-4fe0-944f-cfb7e06e2071/image.png)

이런 경우를 다시 떠올려보자
구현체가 바뀐다고 해도 역할은 바뀌지 않는다.
즉 구현체를 바꾸는 경우에는 열려있으나 역할을 바꾸는 것은 닫혀있다는 것을 의미한다.

인터페이스를 구현한 **새로운 클래스를 만들어서 기능 구현**은 가능하나
그 구현체가 하는 **역할 자체는 바뀌어서 안된다**

> 즉 다형성 자체를 의미하는 원칙이다.

멤버 서비스에서 사용하는 여러 리포지토리를 사용했었다.
그러나 메모리에서 JDBC 리포지토리로 변경하려면 멤버 서비스에서 리포지토리 객체를 변경해야하는데 이건 OCP를 위배한다.

> 이 문제 해결을 위해서 객체를 생성하고 연관관계를 맺어주는 조립 하는 설정자가 필요 
💨 **Spring 컨테이너**가 역할을 수행 

## LSP 리스코프 치환 원칙
프로그램 객체는 프로그램의 정확성을 깨지 않고 하위 타입의 인스턴스로 변경 가능
하위 클래스는 인터페이스 규약을 지켜야한다는 것
다형성을 지원하기 위한 원칙, 인터페이스를 구현한 구현체를 믿고 사용하기 위함

ex) 자동차 엑셀이 앞으로 가는거지 뒤로 가는 엑셀을 만들면 안되는 것 (컴파일 유무의 문제가 아니다)

## ISP 인터페이스 분리 원칙
특정 클라이언트를 위한 인터페이스 여러개가 범용 인터페이스 하나 보다 낫다
예시를 통해서 알아보자
자동차 인터페이스, 사용자 인터페이스 두개 보다는
각각 운전 인터페이스, 정비 인터페이스로 분리하는 것이 유지 보수 면에서도 좋음
사용자 인터페이스도 운전사, 정비사로 나누는 것이 더 좋음
즉 이렇게 나눔으로 서로의 클라이언트들에 영향을 안줌
> 적당한 단위를 인터페이슬르 잘 쪼개는게 중요하다.

## DIP 의존관계 역전 원칙
프로그래머는 추상화에 의존해야하며 구체화에 의존하면 안된다.
구현 클래스가 아니라 인터페이스에 의존해야한다.

즉 구현체가 아니라 **역할에 의존**하게 해야한다는 것이다.
자동차 라는 역할이 있다고 가정하자
여기서 구현체는 각각 벤츠, K3, 티코가 있다.
>여기서 벤츠라는 구현체에 의존해서 하게되면 티코에서는 사용할 수 없는 메소드가 지나치게 많아 질 수 있다. 

즉 인터페이스에 의존해야 여러 구현체에서 사용할 수 있는 것이다.

자동차는 엑셀, 브레이크, 파킹 등 기본 기능이 있어야하는데 벤츠에 의존해서 엉뜨, 서라운드 뷰 등 이런 기능에 집중하면 안된다는 거다.

![](https://velog.velcdn.com/images/kimdodo/post/a1b3a9ff-cef6-4ab4-85c4-a600c5302a1c/image.png)
자 그럼 여기서 예시를 보고 문제를 확인하자 
메모리 리포지토리, jdbc 리포지토리를 사용하는 멤버 서비스는 인터페이스에도 의존하지만 메모리 멤버 리포지토리에도 의존하는 상황이다.

그니까 인터페이스만 아는게 아니라 메모리리포지토리를 알기 때문에 서비스 코드에서 구현체를 변경해야 하는 문제가 있는 것임

> 이 문제는 DIP를 위반하는데 이걸 어떻게 해결하냐 
다음 강의해서 한다!!!💥


## 정리하자면
객체 지향의 핵심은 다형성이다.
위 5가지 원리도 다형성에 기반해서 나온 원칙이라고도 할 수 있음
하지만 다형성만으로는 클라이언트 코드도 변경해야하는데 이게 문제로 작용된다.
이러면 OCP 랑 DIP를 지키기가 불가능하다.
이걸 Spring 이 해결해 주는데 이 해결 방법은 앞으로 Spring을 보면서 알아보자