## CallBack
콜백이 무엇인가
직관적으로 이름을 해석하면 **다시 콜을 다시 달라** 그런 의미이다.
사실 이해가 잘 가지 않아 여러 포스팅을 찾아보고 가장 이해하기 쉬운 예제를 찾았다.
> 친구들과 놀고 집으로 갈때 떡볶이를 사려고 한다.
떡볶이 주문을 하는데 현재 구매시 약 30분 이상의 대기 시간이 필요하다.
그래서 전화번호를 적어놓고 완료되면 전화를 받고 찾아가기로 했다.

이 예시를 통해서 콜백이 뭔지 대략적으로 이해할 수 있다.

A객체의 처리(떡볶이 수령)를 **수행 완료까지 기다리는 것이 아니라** 다른 객체나 **다른 동작을 수행**하고 A 객체의 처리가 **끝나면 알려달라** 이것이 CallBack 이다.
이것이 Non-Blocking 처리인 비동기 방식으로 사용된다.

예제 코드를 통해서 결과를 알아보자


```javascript
plus = function(a,b,callback){
  var result = a+b;
  callback(result);
}

plus(5,10,function(res) {
  console.log(res);
})
```

더하기를 하는 plus 라는 함수를 선언했다.
a,b,callback을 인자값으로 사용한다.
callback은 함수 이름이며 어떤 함수여도 상관 없다.

5,10을 인자값으로 제공하고 함수를 동작하면 callback의 동작으로 result를 전달한다.
그렇게 callback으로 result를 전달하면 function(res)는 res를 출력하는 함수가 되는 것이다.

새로운 예시를 통해서 다시 알아보자

```javascript
pm = function(a,b,callback){
  callback(a+b,a-b);
}

pm(5,10,function(res1,res2){
  console.log(res1)
  console.log(res2)
})
```
해당 과정이 어느정도 이해가 되는가?
무슨 말인지는 알겠지만 이렇게 되는 원리 그리고 동작 순서를 여전히 헷갈리는 부분이 있다.

즉 콜백은 한 작업이 완료를 기다리지 않고 여러 작업을 동시에 수행하게 한다. 
이는 I/O 작업 (파일 읽기, 네트워크 요청, DB 쿼리)에 매우 효율적이다. 앞서 Node 설명할때 Non Blocking I/O 가 핵심 특징이라고 했는데 이것을 의미한다.
문맥 작성시 특정 작업이 완료된 후 어떤 일이 일어나야 하는지 지정하는 것이 매우 중요하다.

```javascript
function 콜백(에러, 결과) {
  if (에러) {
    // 에러 처리
  } else {
    // 결과 사용
  }
}
```
콜백 함수는 이런 구조를 일반적으로 가진다.
위 코드에서 에러는 작업에서 발생할 에러, 결과를 함수 결과를 의미한다.

```javascript
const fs = require('fs');

fs.readFile('file.txt', 'utf8', (에러, 데이터) => {
  if (에러) {
    console.error(에러);
  } else {
    console.log(데이터);
  }
});
```

비동기 함수는 작업을 수행하고 완료되면 제공된 콜백 함수를 호출
위 예제를 기준으로 한다면 fs 모듈을 통해서 파일을 읽을 때 비동기 작업을 수행하고 이때 에러가 발생하면 에러를 출력한다. 콜백 함수 없이 비동기로 오류를 처리하기는 상당히 어렵다.

하지만 콜백 함수에서 주의해야할 문제는 중첩 즉 **콜백 지옥**이라고 불리는 것이다.
서로 의존되는 여러 비동기 작업이 있을때 중첩에 중첩에 중첩이 일어나고 즉 코드가 깊어져 유지보수가 상당히 어려워진다.
이런 문제를 해결하기 위해서 **promise, async/await**가 도입되었다.

